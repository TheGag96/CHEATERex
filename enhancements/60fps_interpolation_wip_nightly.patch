diff --git a/include/PR/gbi.h b/include/PR/gbi.h
index bd981be..921eca5 100644
--- a/include/PR/gbi.h
+++ b/include/PR/gbi.h
@@ -118,6 +118,9 @@
 #define G_SPECIAL_2		0xd4
 #define G_SPECIAL_3		0xd3
 
+#define G_PUSHGRAPHNODE 0xd1
+#define G_POPGRAPHNODE  0xd2
+
 #define G_VTX			0x01
 #define G_MODIFYVTX		0x02
 #define G_CULLDL		0x03
@@ -2981,6 +2984,22 @@ typedef union {
 }}
 #endif
 
+#define gSPPushGraphNode(pkt, layer, node) \
+{ \
+    Gfx *_g = (Gfx *)(pkt); \
+    \
+    _g->words.w0 = (_SHIFTL(G_PUSHGRAPHNODE, 24, 8) | _SHIFTL(layer, 0, 24)); \
+    _g->words.w1 = (uintptr_t)(node); \
+}
+
+#define gSPPopGraphNode(pkt, layer) \
+{ \
+    Gfx *_g = (Gfx *)(pkt); \
+    \
+    _g->words.w0 = (_SHIFTL(G_POPGRAPHNODE, 24, 8) | _SHIFTL(layer, 0, 24)); \
+    _g->words.w1 = 0; \
+}
+
 /*
  * RDP setothermode register commands - register shadowed in RSP
  */
diff --git a/src/buffers/buffers.h b/src/buffers/buffers.h
index 9d1d692..55aecc9 100644
--- a/src/buffers/buffers.h
+++ b/src/buffers/buffers.h
@@ -28,7 +28,7 @@ extern struct SaveBuffer gSaveBuffer;
 
 extern u8 gGfxSPTaskStack[];
 
-#define GFX_NUM_POOLS 1
+#define GFX_NUM_POOLS 2
 
 extern struct GfxPool gGfxPools[GFX_NUM_POOLS];
 
diff --git a/src/game/rendering_graph_node.c b/src/game/rendering_graph_node.c
index 18e70e4..8eaa590 100644
--- a/src/game/rendering_graph_node.c
+++ b/src/game/rendering_graph_node.c
@@ -11,6 +11,9 @@
 #include "shadow.h"
 #include "sm64.h"
 
+#include <assert.h>
+#include <stdio.h>
+
 /**
  * This file contains the code that processes the scene graph for rendering.
  * The scene graph is responsible for drawing everything except the HUD / text boxes.
@@ -125,6 +128,11 @@ struct GraphNodeObject *gCurGraphNodeObject = NULL;
 struct GraphNodeHeldObject *gCurGraphNodeHeldObject = NULL;
 u16 gAreaUpdateCounter = 0;
 
+static struct GraphNode *sGraphNodeStacks[GFX_NUM_MASTER_LISTS][128];
+static u8 sGraphNodeStackDepths[GFX_NUM_MASTER_LISTS];
+static struct GraphNode *sGraphNodeProcessingStack[128];
+static u8 sGraphNodeProcessingStackDepth;
+
 #ifdef F3DEX_GBI_2
 LookAt lookAt;
 #endif
@@ -156,11 +164,26 @@ static void geo_process_master_list_sub(struct GraphNodeMasterList *node) {
         if ((currList = node->listHeads[i]) != NULL) {
             gDPSetRenderMode(gDisplayListHead++, modeList->modes[i], mode2List->modes[i]);
             while (currList != NULL) {
+                if (currList->transform == (void *)1) {
+                    // Pop node
+                    gSPPopGraphNode(gDisplayListHead++, i);
+                    currList = currList->next;
+                    continue;
+                } else if (currList->transform == (void *)2) {
+                    // Push node
+                    gSPPushGraphNode(gDisplayListHead++, i, currList->displayList);
+                    currList = currList->next;
+                    continue;
+                }
                 gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(currList->transform),
                           G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);
                 gSPDisplayList(gDisplayListHead++, currList->displayList);
                 currList = currList->next;
             }
+            while (sGraphNodeStackDepths[i] > 0) {
+                gSPPopGraphNode(gDisplayListHead++, i);
+                sGraphNodeStackDepths[i]--;
+            }
         }
     }
     if (enableZBuffer != 0) {
@@ -169,6 +192,22 @@ static void geo_process_master_list_sub(struct GraphNodeMasterList *node) {
     }
 }
 
+static void geo_append_display_list_node(void *displayList, void *transform, s16 layer) {
+    struct DisplayListNode *listNode =
+        alloc_only_pool_alloc(gDisplayListHeap, sizeof(struct DisplayListNode));
+
+    assert(listNode != NULL);
+    listNode->transform = transform;
+    listNode->displayList = displayList;
+    listNode->next = 0;
+    if (gCurGraphNodeMasterList->listHeads[layer] == 0) {
+        gCurGraphNodeMasterList->listHeads[layer] = listNode;
+    } else {
+        gCurGraphNodeMasterList->listTails[layer]->next = listNode;
+    }
+    gCurGraphNodeMasterList->listTails[layer] = listNode;
+}
+
 /**
  * Appends the display list to one of the master lists based on the layer
  * parameter. Look at the RenderModeContainer struct to see the corresponding
@@ -180,18 +219,30 @@ static void geo_append_display_list(void *displayList, s16 layer) {
     gSPLookAt(gDisplayListHead++, &lookAt);
 #endif
     if (gCurGraphNodeMasterList != 0) {
-        struct DisplayListNode *listNode =
-            alloc_only_pool_alloc(gDisplayListHeap, sizeof(struct DisplayListNode));
-
-        listNode->transform = gMatStackFixed[gMatStackIndex];
-        listNode->displayList = displayList;
-        listNode->next = 0;
-        if (gCurGraphNodeMasterList->listHeads[layer] == 0) {
-            gCurGraphNodeMasterList->listHeads[layer] = listNode;
-        } else {
-            gCurGraphNodeMasterList->listTails[layer]->next = listNode;
+        s32 commonLength = MIN(sGraphNodeStackDepths[layer], sGraphNodeProcessingStackDepth);
+        s32 samePrefixLength = 0;
+        s32 toRemove;
+
+        // The geo "tree" is really a directed acyclic graph, so we must check the whole prefix
+        while (samePrefixLength < commonLength && sGraphNodeStacks[layer][samePrefixLength] == sGraphNodeProcessingStack[samePrefixLength]) {
+            samePrefixLength++;
         }
-        gCurGraphNodeMasterList->listTails[layer] = listNode;
+        toRemove = sGraphNodeStackDepths[layer] - samePrefixLength;
+        while (toRemove > 0) {
+            // Pop node
+            geo_append_display_list_node(NULL, (void *)1, layer);
+            toRemove--;
+        }
+
+        while (samePrefixLength < sGraphNodeProcessingStackDepth) {
+            // Push node
+            sGraphNodeStacks[layer][samePrefixLength] = sGraphNodeProcessingStack[samePrefixLength];
+            geo_append_display_list_node(sGraphNodeProcessingStack[samePrefixLength++], (void *)2, layer);
+        }
+
+        sGraphNodeStackDepths[layer] = samePrefixLength;
+
+        geo_append_display_list_node(displayList, gMatStackFixed[gMatStackIndex], layer);
     }
 }
 
@@ -937,6 +988,46 @@ void geo_try_process_children(struct GraphNode *node) {
     }
 }
 
+static const char *sNodeTypes[] = {
+    "_",
+    "ROOT",
+    "ORTHO_PROJECTION",
+    "PERSPECTIVE",
+    "MASTER_LIST",
+    "_", "_", "_", "_", "_",
+    "START",
+    "LEVEL_OF_DETAIL",
+    "SWITCH_CASE",
+    "_", "_", "_", "_", "_", "_", "_",
+    "CAMERA",
+    "TRANSLATION_ROTATION",
+    "TRANSLATION",
+    "ROTATION",
+    "OBJECT",
+    "ANIMATED_PART",
+    "BILLBOARD",
+    "DISPLAY_LIST",
+    "SCALE",
+    "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",
+    "SHADOW",
+    "OBJECT_PARENT",
+    "GENERATED_LIST",
+    "_",
+    "BACKGROUND",
+    "_",
+    "HELD_OBJ",
+    "CULLING_RADIUS"
+};
+
+static const char *get_node_type(int t) {
+    if (sNodeTypes[t][0] == '_') {
+        static char buf[16];
+        sprintf(buf, "%02x", t);
+        return buf;
+    }
+    return sNodeTypes[t];
+}
+
 /**
  * Process a generic geo node and its siblings.
  * The first argument is the start node, and all its siblings will
@@ -958,6 +1049,15 @@ void geo_process_node_and_siblings(struct GraphNode *firstNode) {
             if (curGraphNode->flags & GRAPH_RENDER_CHILDREN_FIRST) {
                 geo_try_process_children(curGraphNode);
             } else {
+                if (curGraphNode->type == GRAPH_NODE_TYPE_BACKGROUND) {
+                    sGraphNodeProcessingStack[sGraphNodeProcessingStackDepth++] = (void *)(uintptr_t)gGlobalTimer;
+                } else if (curGraphNode->type == GRAPH_NODE_TYPE_SWITCH_CASE || curGraphNode->type == GRAPH_NODE_TYPE_DISPLAY_LIST) {
+                    sGraphNodeProcessingStack[sGraphNodeProcessingStackDepth++] = NULL;
+                } else {
+                    sGraphNodeProcessingStack[sGraphNodeProcessingStackDepth++] = curGraphNode;
+                }
+                /*for (int i = 0; i < sGraphNodeProcessingStackDepth; i++) printf(" ");
+                printf("> %p %s\n", curGraphNode, get_node_type(curGraphNode->type % 0x30));*/
                 switch (curGraphNode->type) {
                     case GRAPH_NODE_TYPE_ORTHO_PROJECTION:
                         geo_process_ortho_projection((struct GraphNodeOrthoProjection *) curGraphNode);
@@ -1021,6 +1121,9 @@ void geo_process_node_and_siblings(struct GraphNode *firstNode) {
                         geo_try_process_children((struct GraphNode *) curGraphNode);
                         break;
                 }
+                /*for (int i = 0; i < sGraphNodeProcessingStackDepth; i++) printf(" ");
+                printf("< %p\n", curGraphNode);*/
+                sGraphNodeProcessingStackDepth--;
             }
         } else {
             if (curGraphNode->type == GRAPH_NODE_TYPE_OBJECT) {
diff --git a/src/pc/gfx/gfx_pc.c b/src/pc/gfx/gfx_pc.c
index 9c4f481..3b5deac 100644
--- a/src/pc/gfx/gfx_pc.c
+++ b/src/pc/gfx/gfx_pc.c
@@ -98,6 +98,21 @@ struct ColorCombiner {
     uint8_t shader_input_mapping[2][4];
 };
 
+#define NUM_LAYERS 8
+struct SavedVertex {
+    float x, y, z, w;
+};
+
+struct SavedGraphNode {
+    uintptr_t id;
+    struct SavedGraphNode *children;
+    struct SavedVertex *vertices;
+    uint32_t children_size;
+    uint32_t children_capacity;
+    uint32_t vertices_size;
+    uint32_t vertices_capacity;
+};
+
 static struct ColorCombiner color_combiner_pool[64];
 static uint8_t color_combiner_pool_size;
 
@@ -123,6 +138,13 @@ static struct RSP {
     } texture_scaling_factor;
     
     struct LoadedVertex loaded_vertices[MAX_VERTICES + 4];
+
+    struct SavedGraphNode saved_graph_nodes[NUM_LAYERS];
+    struct SavedGraphNode *graph_node_stack[128];
+    uint32_t vertex_index_stack[128];
+    uint8_t graph_node_stack_depth;
+    bool interpolated_frame;
+    int8_t current_layer;
 } rsp;
 
 static struct RDP {
@@ -830,6 +852,36 @@ static void gfx_sp_vertex(size_t n_vertices, size_t dest_index, const Vtx *verti
         if (y > w) d->clip_rej |= 8;
         if (z < -w) d->clip_rej |= 16;
         if (z > w) d->clip_rej |= 32;
+    
+        if (rsp.current_layer >= 0) {
+            if (!rsp.interpolated_frame) {
+                struct SavedGraphNode *cur_top = rsp.graph_node_stack[rsp.graph_node_stack_depth - 1];
+                if (cur_top->vertices_size == cur_top->vertices_capacity) {
+                    if (cur_top->vertices_capacity == 0) {
+                        cur_top->vertices_capacity = 4;
+                    }
+                    cur_top->vertices_capacity *= 2;
+                    cur_top->vertices = (struct SavedVertex *)realloc(cur_top->vertices, cur_top->vertices_capacity * sizeof(struct SavedVertex));
+                }
+                struct SavedVertex *sv = &cur_top->vertices[cur_top->vertices_size++];
+                sv->x = x;
+                sv->y = y;
+                sv->z = z;
+                sv->w = w;
+            } else {
+                struct SavedGraphNode *cur_top = rsp.graph_node_stack[rsp.graph_node_stack_depth - 1];
+                if (cur_top != NULL) {
+                    uint32_t *vtx_idx = &rsp.vertex_index_stack[rsp.graph_node_stack_depth - 1];
+                    if (*vtx_idx < cur_top->vertices_size) {
+                        struct SavedVertex *sv = &cur_top->vertices[(*vtx_idx)++];
+                        x = (x + sv->x) / 2.0f;
+                        y = (y + sv->y) / 2.0f;
+                        z = (z + sv->z) / 2.0f;
+                        w = (w + sv->w) / 2.0f;
+                    }
+                }
+            }
+        }
         
         d->x = x;
         d->y = y;
@@ -1155,6 +1207,54 @@ static void gfx_sp_texture(uint16_t sc, uint16_t tc, uint8_t level, uint8_t tile
     rsp.texture_scaling_factor.t = tc;
 }
 
+static void gfx_sp_push_graph_node(uint8_t layer, uintptr_t id) {
+    if (rsp.current_layer != layer) {
+        assert(rsp.graph_node_stack_depth <= 1);
+        rsp.graph_node_stack[0] = &rsp.saved_graph_nodes[layer];
+        rsp.graph_node_stack_depth = 1;
+        rsp.current_layer = layer;
+    }
+    struct SavedGraphNode *cur_top = rsp.graph_node_stack[rsp.graph_node_stack_depth - 1];
+
+    if (!rsp.interpolated_frame) {
+        if (cur_top->children_size == cur_top->children_capacity) {
+            if (cur_top->children_capacity == 0) {
+                cur_top->children_capacity = 1;
+            }
+            cur_top->children_capacity *= 2;
+            cur_top->children = (struct SavedGraphNode *)realloc(cur_top->children, cur_top->children_capacity * sizeof(struct SavedGraphNode));
+        }
+        cur_top = &cur_top->children[cur_top->children_size++];
+        memset(cur_top, 0, sizeof(*cur_top));
+        cur_top->id = id;
+        rsp.graph_node_stack[rsp.graph_node_stack_depth++] = cur_top;
+    } else {
+        struct SavedGraphNode *new_top = NULL;
+        if (cur_top != NULL) {
+            for (uint32_t i = 0; i < cur_top->children_size; i++) {
+                struct SavedGraphNode *child = &cur_top->children[i];
+                if (child->id == id) {
+                    new_top = child;
+                    break;
+                }
+            }
+        }
+        rsp.vertex_index_stack[rsp.graph_node_stack_depth] = 0;
+        rsp.graph_node_stack[rsp.graph_node_stack_depth++] = new_top;
+        //for (int i = 0; i < rsp.graph_node_stack_depth - 1; i++) printf(" ");
+        //printf("> %p%s\n", (void *)id, new_top != NULL ? " FOUND" : "-");
+    }
+    assert(rsp.graph_node_stack_depth <= 128);
+}
+
+static void gfx_sp_pop_graph_node(uint8_t layer) {
+    assert(rsp.graph_node_stack_depth > 1);
+    if (--rsp.graph_node_stack_depth == 1) {
+        // Root node reached
+        rsp.current_layer = -1;
+    }
+}
+
 static void gfx_dp_set_scissor(uint32_t mode, uint32_t ulx, uint32_t uly, uint32_t lrx, uint32_t lry) {
     float x = ulx / 4.0f * RATIO_X;
     float y = (SCREEN_HEIGHT - lry / 4.0f) * RATIO_Y;
@@ -1607,6 +1707,13 @@ static void gfx_run_dl(Gfx* cmd) {
                 gfx_sp_set_other_mode(C0(8, 8) + 32, C0(0, 8), (uint64_t) cmd->words.w1 << 32);
 #endif
                 break;
+
+            case G_PUSHGRAPHNODE:
+                gfx_sp_push_graph_node(C0(0, 8), cmd->words.w1);
+                break;
+            case G_POPGRAPHNODE:
+                gfx_sp_pop_graph_node(C0(0, 8));
+                break;
             
             // RDP Commands:
             case G_SETTIMG:
@@ -1714,6 +1821,7 @@ static void gfx_sp_reset() {
     rsp.modelview_matrix_stack_size = 1;
     rsp.current_num_lights = 2;
     rsp.lights_changed = true;
+    rsp.current_layer = -1;
 }
 
 void gfx_get_dimensions(uint32_t *width, uint32_t *height) {
@@ -1777,8 +1885,21 @@ void gfx_start_frame(void) {
     gfx_current_dimensions.aspect_ratio = (float)gfx_current_dimensions.width / (float)gfx_current_dimensions.height;
 }
 
+static void gfx_clear_graph_nodes(struct SavedGraphNode *node) {
+    if (node->children_capacity > 0) {
+        for (uint32_t i = 0; i < node->children_size; i++) {
+            gfx_clear_graph_nodes(&node->children[i]);
+        }
+        free(node->children);
+    }
+    if (node->vertices_capacity > 0) {
+        free(node->vertices);
+    }
+}
+
 void gfx_run(Gfx *commands) {
     gfx_sp_reset();
+    rsp.interpolated_frame = true;
     
     //puts("New frame");
     
@@ -1795,6 +1916,27 @@ void gfx_run(Gfx *commands) {
     double t1 = gfx_wapi->get_time();
     //printf("Process %f %f\n", t1, t1 - t0);
     gfx_wapi->swap_buffers_begin();
+    rsp.interpolated_frame = false;
+    for (int i = 0; i < NUM_LAYERS; i++) {
+        gfx_clear_graph_nodes(&rsp.saved_graph_nodes[i]);
+    }
+    memset(rsp.saved_graph_nodes, 0, sizeof(rsp.saved_graph_nodes));
+
+    gfx_wapi->swap_buffers_end();
+
+    if (!gfx_wapi->start_frame()) {
+        dropped_frame = true;
+        return;
+    }
+    dropped_frame = false;
+
+    t0 = gfx_wapi->get_time();
+    gfx_rapi->start_frame();
+    gfx_run_dl(commands);
+    gfx_flush();
+    t1 = gfx_wapi->get_time();
+    //printf("Process %f %f\n", t1, t1 - t0);
+    gfx_wapi->swap_buffers_begin();
 }
 
 void gfx_end_frame(void) {
